- Server、Clientの通信暗号化
	1. https化
		自己署名証明書で暗号化
		go/src/crypto/tls/generate_cert.goで生成可能
	2. 自前で暗号化
		公開鍵生成→共通鍵送信
		javaはbouncy castle、goはcrypto/rsa、crypt/aesで暗号扱える
		rsaの2048bit、aesの256bit使う
		rsa公開鍵はder形式、aes共通鍵は(初期ベクトル長)(初期ベクトルbase64)(鍵長)(鍵base64)で送信
	3. API認証
		一般的なAPI認証の手法を取り入れる
- 接続方法案
	サーバーは秘密鍵を固定
	クライアント		サーバー

	UDP 乱数、(乱数、IP、パスワード)ハッシュ	→ 
			← UDP 公開鍵、(ハッシュ、公開鍵、IP、パスワード)ハッシュ
	HTTP (共通鍵、(共通鍵、IP、パスワード)ハッシュ)暗号化 →
			← HTTP_OK

- HTTP(s)の使い方変更
	- Requestに入れるのではなく、全部Bodyにjson形式で入れる

	
- 同期機能の自動起動
	- foreground serviceに変更する案(syncthingはこれ)
	
- 通信データの圧縮
	- gzipがgoでもjavaでも使える
- 読み込みの並列化
- UIの改善
- 指定Wifiでのみ送信する設定
- 競合との差別化
- Wifi接続時のみ動作



- 前回からの差分
	- 接続の暗号化
		- 共通鍵交換用のRSA暗号、データ暗号化用のARS暗号
		- サーバー起動毎にRSA暗号を発行する(本当はファイルに保存しておくべきだが、そのセキュリティを担保できないため)
	- 接続プロセス変更
		- IPアドレスと鍵をハッシュ対象に変更
		- IPアドレスをハッシュ化に追加することで、正規のサーバー・クライアントのデータを使ってIPアドレスのみを差し替えた攻撃に対策
		- 乱数を時間依存からセキュリティに配慮したSecureRandomに変更
			- 乱数を事前に予測しにくく
	- 
		